package redcrypt

import (
	"bytes"
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"io"
)

const BlockSize = 16

func Redcrypt(key string, plaintextbytes []byte) []byte {
	keybytes := []byte(key)
	//check keysize?

	//Check block size and if not long enough pad it
	//Goroutine here?
	blockcheck := len(plaintextbytes) % aes.BlockSize
	var paddedbytes []byte
	if blockcheck != 0 {
		padding := bytes.Repeat([]byte("A"), (16-blockcheck))
		paddedbytes = append(plaintextbytes, padding...)
	} else {
		paddedbytes = plaintextbytes
	}
	//Block
	block, err := aes.NewCipher(keybytes)
	if err != nil {
		panic(err)
	}

	//Initialisation vector
	ciphertext := make([]byte, aes.BlockSize+len(paddedbytes))
	iv := ciphertext[:aes.BlockSize]
	if _, err := io.ReadFull(rand.Reader, iv); err != nil {
		panic(err)
	}

	mode := cipher.NewCBCEncrypter(block, iv)
	mode.CryptBlocks(ciphertext[aes.BlockSize:], paddedbytes)

	return ciphertext
}
