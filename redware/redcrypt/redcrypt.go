package redcrypt

import (
	"bytes"
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"fmt"
	"io"
)

const BlockSize = 16

func Redcrypt(key string, plaintext string) []byte{
	keybytes := []byte(key)
	plaintextbytes := []byte(plaintext)
	//check keysize?

	//Check block size and if not long enough
	//Goroutine here?
	fmt.Printf("length plaintextbytes before padding =  %v", len(plaintextbytes))
	for i := 0; i <= len(plaintextbytes); i += 16 {
		if i > len(plaintextbytes) - 16{
			padding := bytes.Repeat([]byte("A"), len(plaintextbytes)-i)
			plaintextbytes = append(plaintextbytes, padding...)
		} else{
			continue
		}
	}

	if len(plaintextbytes)%aes.BlockSize != 0 {
		panic ("plaintext not multiple of block size")
	}

	//Block
	block, err := aes.NewCipher(keybytes)
	if err != nil {
		panic(err)
	}

	//Initialisation vector
	ciphertext := make([]byte, aes.BlockSize+len(plaintextbytes))
	iv := ciphertext[:aes.BlockSize]
	if _, err := io.ReadFull(rand.Reader, iv); err != nil {
		panic(err)
	}

	mode := cipher.NewCBCEncrypter(block, iv)
	mode.CryptBlocks(ciphertext[aes.BlockSize:], plaintextbytes)

	return ciphertext
}