package keycomm

import (
	"bytes"
	"encoding/json"
	"errors"
	"log"
	"math/big"
	"net/http"
	"syscall"
	"time"

	"crypto/ecdsa"
	"crypto/elliptic"
	"fmt"
)

var mess *http.Response

type Key struct {
	CurveParams *elliptic.CurveParams `json:"Curve"`
	X           *big.Int              `json:"X"`
	Y           *big.Int              `json:"Y"`
}

func check(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

func CallHome(pubkt ecdsa.PublicKey, address string) (pubks *Key, err error) {
	// Encode public key provided
	cbuff, err := json.Marshal(pubkt)
	check(err)
	
	// Try connecting back home
	mess, err = http.Post(address, "application/json", bytes.NewBuffer(cbuff))
	for i := 0; errors.Is(err, syscall.Errno(10061)) && i <= 10; i++ {
	mess, err = http.Post(address, "application/json", bytes.NewBuffer(cbuff))
	time.Sleep(1*time.Second) // TODO: change to longer period after testing
	} 
	
	// Check result and either (a) quit function with error or (b) proceed with decoding 
	if mess == nil {
		err := fmt.Errorf("connection error")
		return nil, err
	}else{
		pubks = new(Key)
		jsonerr := json.NewDecoder(mess.Body).Decode(&pubks)
		check(jsonerr)
		fmt.Printf("\n Server public key: %v", pubks)
		defer mess.Body.Close()
		return pubks, nil
	}
}
