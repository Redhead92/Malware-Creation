package reddecrypt

import (
	"crypto/aes"
	"crypto/cipher"
	"fmt"
	"os"
	"regexp"
)

func check(e error) {
	if e != nil {
		panic(e)
	}
}

func Reddecrypt(file string, key []byte) {

	// read file
	cryptfile, err := os.ReadFile(file)
	check(err)

	//Block
	block, err := aes.NewCipher(key)
	check(err)
	
	iv := cryptfile[:aes.BlockSize]
	cipherbytes := cryptfile[aes.BlockSize:]

	// CBC mode always works in whole blocks.
	if len(cipherbytes)%aes.BlockSize != 0 {
		panic("ciphertext is not a multiple of the block size")
	}

	plaintextbytes := make([]byte, len(cipherbytes))
	mode := cipher.NewCBCDecrypter(block, iv)
	mode.CryptBlocks(plaintextbytes, cipherbytes)

	// Depadding plaintext
	rp := regexp.MustCompile(`(A*$)`)
	depadbytes := []byte(rp.ReplaceAllString(string(plaintextbytes), ""))

	//Extract file info
	//Look for all drive strings (i.e. C:/)
	r := regexp.MustCompile(`(\w:\/)`)
	// Find all matches to the string and yank out the last match
	// This should be the filepath we added during encryption
	stringmatches := r.FindAllStringIndex(string(depadbytes), -1)

	// Check if string matches and write plaintext file minus added filepath
	if stringmatches != nil {
		orFilename := string(depadbytes[stringmatches[len(stringmatches)-1][0]:])
		// Check if by any chance file already exists
		err = os.WriteFile(orFilename, depadbytes[:len(depadbytes)-len(orFilename)], 0666)
		if os.IsExist(err)  {
			fmt.Println("Target file already exists")
		} else{
		fmt.Printf("Decrypted file: , %s back to %s \n", file, orFilename)
		}
	}

}
